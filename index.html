<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>üìö My Document Library</title>
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
<style>
  body { background:#f8f9fa; font-family:system-ui, -apple-system, Segoe UI, Roboto, 'Helvetica Neue', Arial; }
  .navbar { background:#2d2d2d; }
  .navbar-brand { color:#fff !important; font-weight:700; }
  .container-narrow { max-width: 980px; margin:auto; padding:24px 16px; }
  .card-like { background:#fff; border-radius:14px; box-shadow:0 6px 20px rgba(0,0,0,.08); padding:20px; }
  .file-card { background:#fff; border-radius:12px; box-shadow:0 2px 8px rgba(0,0,0,.06);
               padding:12px 16px; display:flex; align-items:center; justify-content:space-between; margin-bottom:10px; }
  .file-name { font-weight:600; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; max-width:60vw; }
  .viewer { margin-top:24px; }
  iframe, .viewer-pane { width:100%; height:70vh; border:none; border-radius:12px; background:#fff;
                         box-shadow:0 4px 20px rgba(0,0,0,.08); padding:0; }
  .viewer-pane { overflow:auto; padding:16px; }
  .muted { color:#6c757d; }
</style>
</head>
<body>
<nav class="navbar">
  <div class="container container-narrow">
    <a class="navbar-brand" href="#">üìö My Document Library</a>
  </div>
</nav>

<div class="container container-narrow">
  <div class="card-like mb-4">
    <h1 class="h4 mb-3">Upload your documents</h1>
    <div class="row g-2 align-items-center">
      <div class="col-12 col-md">
        <input id="fileInput" type="file" class="form-control" multiple
               accept=".pdf,.txt,.doc,.docx,.xls,.xlsx,.ppt,.pptx" />
      </div>
      <div class="col-12 col-md-auto">
        <button class="btn btn-dark" id="btnUpload">Upload</button>
        <button class="btn btn-outline-secondary" id="btnClearAll">Clear All</button>
      </div>
      <div class="col-12"><small class="muted">
        Supported: PDF, TXT, DOC/DOCX (preview DOCX), XLS/XLSX (preview), PPT/PPTX (download only for now).
      </small></div>
    </div>
  </div>

  <div class="mb-2 d-flex justify-content-between align-items-center">
    <h2 class="h5 mb-0">üìÇ Readings Comprehension of College</h2>
    <small class="muted" id="storageInfo"></small>
  </div>

  <div id="fileList"></div>

  <div id="viewer" class="viewer" style="display:none;">
    <h3 class="h6" id="viewerTitle">Preview</h3>
    <iframe id="pdfFrame" style="display:none;"></iframe>
    <div id="htmlPane" class="viewer-pane" style="display:none;"></div>
    <div id="tablePane" class="viewer-pane" style="display:none;"></div>
    <div id="messagePane" class="viewer-pane" style="display:none;"></div>
  </div>
</div>

<!-- Dependencies for previews -->
<script src="https://cdn.jsdelivr.net/npm/mammoth@1.6.0/mammoth.browser.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

<script>
/* ---------------------- IndexedDB minimal wrapper ---------------------- */
const DB_NAME = 'doclib-db';
const STORE = 'files';
let db;

function openDB() {
  return new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, 1);
    req.onupgradeneeded = (e) => {
      const db = e.target.result;
      if (!db.objectStoreNames.contains(STORE)) {
        const os = db.createObjectStore(STORE, { keyPath: 'id', autoIncrement: true });
        os.createIndex('name', 'name', { unique: false });
        os.createIndex('type', 'type', { unique: false });
        os.createIndex('ts', 'ts', { unique: false });
      }
    };
    req.onsuccess = (e) => { db = e.target.result; resolve(db); };
    req.onerror = (e) => reject(e.target.error);
  });
}
function addFile(rec) {
  return new Promise((res, rej) => {
    const tx = db.transaction(STORE, 'readwrite');
    tx.objectStore(STORE).add(rec).onsuccess = () => res();
    tx.onerror = (e) => rej(e.target.error);
  });
}
function listFiles() {
  return new Promise((res, rej) => {
    const out = [];
    const tx = db.transaction(STORE, 'readonly');
    tx.objectStore(STORE).openCursor().onsuccess = (e) => {
      const cur = e.target.result;
      if (cur) { out.push(cur.value); cur.continue(); } else { res(out.sort((a,b)=>b.ts-a.ts)); }
    };
    tx.onerror = (e) => rej(e.target.error);
  });
}
function getFile(id) {
  return new Promise((res, rej) => {
    const tx = db.transaction(STORE, 'readonly');
    tx.objectStore(STORE).get(id).onsuccess = (e) => res(e.target.result);
    tx.onerror = (e) => rej(e.target.error);
  });
}
function delFile(id) {
  return new Promise((res, rej) => {
    const tx = db.transaction(STORE, 'readwrite');
    tx.objectStore(STORE).delete(id).onsuccess = () => res();
    tx.onerror = (e) => rej(e.target.error);
  });
}
function clearAll() {
  return new Promise((res, rej) => {
    const tx = db.transaction(STORE, 'readwrite');
    tx.objectStore(STORE).clear().onsuccess = () => res();
    tx.onerror = (e) => rej(e.target.error);
  });
}

/* ----------------------------- UI helpers ----------------------------- */
const fileInput = document.getElementById('fileInput');
const btnUpload = document.getElementById('btnUpload');
const btnClearAll = document.getElementById('btnClearAll');
const fileList = document.getElementById('fileList');
const storageInfo = document.getElementById('storageInfo');

const viewer = document.getElementById('viewer');
const viewerTitle = document.getElementById('viewerTitle');
const pdfFrame = document.getElementById('pdfFrame');
const htmlPane = document.getElementById('htmlPane');
const tablePane = document.getElementById('tablePane');
const messagePane = document.getElementById('messagePane');

function fmtBytes(bytes) {
  if (bytes === 0) return '0 B';
  const k = 1024, sizes = ['B','KB','MB','GB','TB'];
  const i = Math.floor(Math.log(bytes)/Math.log(k));
  return (bytes/Math.pow(k,i)).toFixed(2)+' '+sizes[i];
}
async function estimateUsage() {
  if (navigator.storage && navigator.storage.estimate) {
    const est = await navigator.storage.estimate();
    storageInfo.textContent = `Stored ~${fmtBytes(est.usage || 0)} of ${fmtBytes(est.quota || 0)} available`;
  }
}

function iconFor(name) {
  const ext = name.split('.').pop().toLowerCase();
  const map = { pdf:'üìï', txt:'üìù', doc:'üìÑ', docx:'üìÑ', xls:'üìä', xlsx:'üìä', ppt:'üñºÔ∏è', pptx:'üñºÔ∏è' };
  return map[ext] || 'üìÅ';
}

function renderList(items) {
  fileList.innerHTML = '';
  if (!items.length) {
    fileList.innerHTML = '<div class="text-muted">No files yet. Upload above.</div>';
    return;
  }
  for (const f of items) {
    const row = document.createElement('div');
    row.className = 'file-card';
    row.innerHTML = `
      <div class="d-flex align-items-center gap-2">
        <span style="font-size:20px">${iconFor(f.name)}</span>
        <div class="file-name" title="${f.name}">${f.name}</div>
        <small class="muted ms-2">${fmtBytes(f.size || 0)}</small>
      </div>
      <div class="d-flex gap-2">
        <button class="btn btn-primary btn-sm" data-action="preview" data-id="${f.id}">Preview</button>
        <a class="btn btn-outline-primary btn-sm" data-action="download" data-id="${f.id}">Download</a>
        <button class="btn btn-danger btn-sm" data-action="delete" data-id="${f.id}">Delete</button>
      </div>
    `;
    fileList.appendChild(row);
  }
}

fileList.addEventListener('click', async (e) => {
  const btn = e.target.closest('[data-action]');
  if (!btn) return;
  const id = Number(btn.dataset.id);
  const rec = await getFile(id);
  if (!rec) return;

  if (btn.dataset.action === 'delete') {
    if (confirm(`Delete "${rec.name}"?`)) {
      await delFile(id);
      await refreshList();
    }
    return;
  }

  if (btn.dataset.action === 'download') {
    const blob = new Blob([rec.data], { type: rec.type || 'application/octet-stream' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = rec.name; a.click();
    URL.revokeObjectURL(url);
    return;
  }

  if (btn.dataset.action === 'preview') {
    await previewFile(rec);
  }
});

async function previewFile(rec) {
  viewer.style.display = 'block';
  viewerTitle.textContent = 'Preview: ' + rec.name;
  pdfFrame.style.display = 'none';
  htmlPane.style.display = 'none';
  tablePane.style.display = 'none';
  messagePane.style.display = 'none';
  messagePane.innerHTML = '';

  const name = rec.name.toLowerCase();
  const blob = new Blob([rec.data], { type: rec.type || 'application/octet-stream' });

  if (name.endsWith('.pdf')) {
    const url = URL.createObjectURL(blob);
    pdfFrame.src = url;
    pdfFrame.style.display = 'block';
    return;
  }

  if (name.endsWith('.txt')) {
    const text = await blob.text();
    htmlPane.innerHTML = `<pre style="white-space:pre-wrap">${escapeHtml(text)}</pre>`;
    htmlPane.style.display = 'block';
    return;
  }

  if (name.endsWith('.docx')) {
    const arrayBuffer = await blob.arrayBuffer();
    mammoth.convertToHtml({ arrayBuffer }).then(result => {
      htmlPane.innerHTML = result.value;
      htmlPane.style.display = 'block';
    }).catch(() => {
      messagePane.innerHTML = warn('Could not render DOCX. You can download and open it.');
      messagePane.style.display = 'block';
    });
    return;
  }

  if (name.endsWith('.xlsx') || name.endsWith('.xls')) {
    try {
      const data = await blob.arrayBuffer();
      const wb = XLSX.read(data, { type: 'array' });
      const first = wb.SheetNames[0];
      const html = XLSX.utils.sheet_to_html(wb.Sheets[first], { editable:false, header:"", footer:"" });
      tablePane.innerHTML = html;
      tablePane.style.display = 'block';
    } catch {
      messagePane.innerHTML = warn('Could not render spreadsheet. You can download and open it.');
      messagePane.style.display = 'block';
    }
    return;
  }

  if (name.endsWith('.doc') || name.endsWith('.ppt') || name.endsWith('.pptx')) {
    messagePane.innerHTML = info('Preview for this format is not available in this lightweight version. Please download and open.');
    messagePane.style.display = 'block';
    return;
  }

  messagePane.innerHTML = info('Preview not supported. You can download the file.');
  messagePane.style.display = 'block';
}

function warn(msg){ return `<div class="alert alert-warning mb-0">${msg}</div>`; }
function info(msg){ return `<div class="alert alert-info mb-0">${msg}</div>`; }
function escapeHtml(s){ return s.replace(/[&<>"']/g, m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[m])); }

btnUpload.addEventListener('click', async () => {
  const files = Array.from(fileInput.files || []);
  if (!files.length) return alert('Select at least one file.');
  for (const f of files) {
    const buf = await f.arrayBuffer();
    await addFile({
      name: f.name,
      type: f.type || guessType(f.name),
      size: f.size,
      ts: Date.now(),
      data: new Uint8Array(buf)
    });
  }
  fileInput.value = '';
  await refreshList();
});

btnClearAll.addEventListener('click', async () => {
  if (confirm('Clear ALL stored files?')) {
    await clearAll();
    await refreshList();
    viewer.style.display = 'none';
  }
});

function guessType(name){
  const ext = name.split('.').pop().toLowerCase();
  const m = {
    pdf:'application/pdf', txt:'text/plain',
    docx:'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
    xlsx:'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
    xls:'application/vnd.ms-excel',
    doc:'application/msword',
    ppt:'application/vnd.ms-powerpoint',
    pptx:'application/vnd.openxmlformats-officedocument.presentationml.presentation'
  };
  return m[ext] || 'application/octet-stream';
}

async function refreshList(){
  const items = await listFiles();
  renderList(items);
  estimateUsage();
}

openDB().then(refreshList);
</script>
</body>
</html>

